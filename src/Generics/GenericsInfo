
  ## 제네릭 Generics
 - 컴파일 시 타입을 체크해 주는 기능으로 내가 원하는 타입의 객체만 저장할 수 있다.
  - extends 키워드로 상속받은 관계에서만 대입이 가능하도록 제한할 수 있다.
    ( Class Test<T, extends A> => A와 A의 자식클래스만 대입 가능 )
    => 인터페이스도 마찬가지로 extends 키워드 사용
 - 제네릭을 사용하면 저장되는 데이터 타입을 고정시켜 객체의 타입 안정성을 높이고 형변환이 생략 가능해 형변환의 번거로움이 줄어든다.
   => 저장되는 데이터 타입이 다를 경우 기존 런 타임 에러를 컴파일 에러로 프로그램 실행 전 확인할 수 있다.
   => 참조변수의 데이터 타입과 생성자의 대입된 타입은 일치해야 하고 일치되면 형변환을 생략할 수 있다. ( ArrayList <T> = new List<T>(); )
     ex1 | 제네릭을 사용해 형변환을 생략해보자.

- 타입 변수는 개별적인 인스턴스마다 다르게 할 수 있기 때문에 static 멤버에는 타입 변수를 사용할 수 없다.
- 배열 생성할 때 타입 변수(t[] toArray = new T[])는 사용할 수 없지만 타입 변수로 배열 선언(T [] itemArr =new ~)은 가능하다.


 타입 변수 T
 - 클래스를 작성할 때, Object타입 대신 타입 변수(T)를 선언해서 사용한다.
 - 객체 생성 시, 타입변수T 대신 실제 데이터 타입(Display 등)을 대입해줄 수 있다.

 HashMap <K,V>
 - Key : Value 쌍으로 데이터값을 저장하므로 hashMap의 경우 타입 변수는 K,V로 정의한다.
  ex2 | 제네릭을 사용하여 hashMap을 작성해보자

