
  ## 제네릭 Generics
 - 컴파일 시 타입을 체크해 주는 기능으로 내가 원하는 타입의 객체만 저장할 수 있다.
  - extends 키워드로 상속받은 관계에서만 대입이 가능하도록 제한할 수 있다.
    ( Class Test<T, extends A> => A와 A의 자식클래스만 대입 가능 )
    => 인터페이스도 마찬가지로 extends 키워드 사용한다.

 - 제네릭을 사용하면 저장되는 데이터 타입을 고정시켜 객체의 타입 안정성을 높이고 형변환이 생략 가능해 형변환의 번거로움이 줄어든다.
   => 저장되는 데이터 타입이 다를 경우 기존 런 타임 에러를 컴파일 에러로 프로그램 실행 전 확인할 수 있다.
   => 참조변수의 데이터 타입과 생성자의 대입된 타입은 일치해야 하고 일치되면 형변환을 생략할 수 있다. ( ArrayList <T> = new List<T>(); )
 - 제네릭 타입과 원시 타입 간의 형변환은 바람직하지 않다.
 - 타입 변수는 개별적인 인스턴스마다 다르게 할 수 있기 때문에 static 멤버에는 타입 변수를 사용할 수 없다.
 - 배열 생성할 때 타입 변수(t[] toArray = new T[])는 사용할 수 없지만 타입 변수로 배열 선언(T [] itemArr =new ~)은 가능하다.
 - 컴파일러는 컴파일 타임에 제네릭을 제거하고 필요한 곳에 형변환을 넣어 하위 호환성을 지킨다.
 - 만약 컴파일러가 제네릭을 제거한 후 타입이 불일치 하면, 자동으로 형변환을 추가 해준다.
    ex1 | 제네릭을 사용해 형변환을 생략해보자.

 HashMap <K,V>
 - Key : Value 쌍으로 데이터값을 저장하므로 hashMap의 경우 타입 변수는 K,V로 정의한다.
 ex2 | 제네릭을 사용하여 hashMap을 작성해보자.

 타입 변수 T
 - 클래스를 작성할 때, Object타입 대신 타입 변수(T)를 선언해서 사용한다.
 - 객체 생성 시, 타입변수T 대신 실제 데이터 타입(Display 등)을 대입해줄 수 있다.
 - 클래스에 타입변수로 제네릭을 선언 하지 않고 클래스 내부의 메소드에만 타입변수로 제네릭을 선언할 수 있다.
 ex3 | 타입 변수를 사용하여 제네릭을 만들어보자.

 와일드 카드 <?>
 - 하나의 참조 변수로 대입된 타입이 다른 객체를 저장 가능
 <T extends class & interface> : class 자신을 포함한 자식 클래스 중 인터페이스를 구현한 타입만 저장 가능
 <T extends interface> : interface를 구현한 클래스만 저장 가능
 <T extends class> : T와 T의 자식클래스만 저장 가능
 <T super class> : T와 T의 부모클래스만 저장 가능
 <T> : 제한 없이 모든 타입 저장 가능 ( <T> = <T extends Object> )
 ex4 | 와일드카드를 사용해보자.


