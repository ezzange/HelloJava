
  ## 프로세스와 쓰레드
  프로세스 ( Process ) : 실행 중인 프로그램, 메모리와 CPU같은 자원과 쓰레드로 나뉜다,
  쓰레드 ( Thread ) : 프로세스 내에서 실제 작업을 수행하며 모든 프로세스는 최소 하나의 쓰레드를 가지고 있다.
  쓰레드는 상속 혹은 구현할 수 있다.
     1. extends Thread => 쓰레드 상속
        ( 클래스 Thread의 메서드 run()을 오버라이딩 )
     2. implements Runnable => 쓰레드 구현
        ( 인터페이스 Runnable의 추상메서드 run()을 구현 )
 ex1 | 쓰레드를 작성해보자.

  싱글 쓰레드 프로세스 : 자원 + 쓰레드
  멀티 쓰레드 프로세스 : 자원 + 쓰레드 + 쓰레드 + ... + 쓰레드
      멀티 쓰레드의 경우 작업이 분리되어 코드가 간결해지고 시스템의 자원을 보다 효율적으로 사용하여 사용자에 대한 응답성이 향상된다.
      하지만 동기화와 교착상태(dead-lock : 쓰레드끼리 원하는 자원을 달라고 하면서 대치하는 상황)가 발생하지 않도록 주의하고
      쓰레드가 효율적으로 실행될 수 있도록 신경 써야한다.
      ( ex - 채팅창에 사진을 보내면서 상대방의 채팅이 오고 그 채팅에 답할 수 있도록 여러 작업이 한번에 수행되는 것. )
 ex2 | 멀티쓰레드는 작업을 번갈아가며 수행하는 것을 확인할 수 있다.

  데몬 쓰레드(daemin thread)
  - 일반 쓰레드의 작업을 돕는 보조적인 역할을 수행한다.
  - 일반 쓰레드가 모두 종료하면, 자동 종료
  - 가비지 컬렉터, 자동저장, 화면 자동갱신 등에 사영할 수 있다.
  - main메서드가 종료되어도 실행하는 쓰레드가 있다면 프로그램은 종료되지 않는다.
  - setDaemon(boolean on)은 반드시 start()가 호출하기 전에 실행되어야 한다.

  쓰레드의 I/O 블락킹
  - 입력(input) / 출력(output) 시 외부장치에 의하여 작업이 중단되고 기다리는 구간
  - 멀티 쓰레드를 사용하는 경우 하나의 쓰레드가 사용자로부터 입력을 기다리는 동안 별도의 쓰레드가 작업을 처리하면서 효율적으로 작업을 처리할 수 있다.
 ex3 | 직접 사용해보자.

  쓰레드의 우선 순위
  - 작업의 중요도를 따라 쓰레드의 우선순위를 정하여 순차적으로 특정 쓰레드가 더 많은 작업시간을 갖도록 할 수 있지만
    쓰레드의 작업은 프로그램 운영체제의 알고리즘에 따라 중요도 순위가 바뀔 수 있어 100% 확정적인 것은 아니다.
    void setProiority(int newProiority) : 쓰레드의 우선순위를 지정한 값으로 변경한다. ( 1-(최소) ~ 10-(최대) )
    int getProiority() : 쓰레드의 우선순위를 반영한다.

  쓰레드 그룹
  - 모든 쓰레드는 반드시 하나의 쓰레드 그룹에 포함되어 있어야 하고 지정하지 않으면 main쓰레드 그룹에 속한다.
  - 서로 관련된 쓰레드를 그룹으로 묶어서 다루기 위한 것으로 자신을 생성한 쓰레드(부모쓰레드)의 그룹과 우선순위를 상속받는다.

( Thread Method )
    void interrupt() : 대기상태(WAITING)인 쓰레드를 실행대기 상태(RUNNABLE)로 만든다 (쓰레드의 interrupted 상태를 false를 ture로 반환)
    boolean isInterrupted() : 쓰레드의 interrupted 상태를 반환
    static boolean interrupted() 현재 쓰레드의 interrupted상태를 알려주고, falue로 초기화
        ex4 | interrupt(), isInterrupted(), interrupted()를 사용해보자.

    dead-lock 교착 상태를 유발할 수 있는 메서드
                suspend()-일시정지
                resume()-일시정지->실행대기
                stop()-쓰레드 종료
        ex5 | 해당 메서드를 직접 사용해보자.

    join() : 지정된 시간 혹은 기본값(작업이 모두 끝날때까지)동안 쓰레드가 작업을 기다린다.
        ex6 | 직접 사용해보자.
    yield() : 쓰레드가 배정 받은 작업 시간 중 남은 시간을 다음 쓰레드에 양보하고, 자신은 실행대기한다.
        ex7 | 직접 사용해보자.

  쓰레드의 동기화
  - 멀티 쓰레드 프로세스에서 한 쓰레드가 진행중인 작업을 다른 쓰레드가 간섭 하지 못하게 막는 것
  - 동기화를 하려면 간섭 받지 않을 문장들을 '임계 영역'으로 설정할 수 있다.
  - 자바는 하나의 객체 당 하나의 락을 가지고 있는데 임계영역은 락(lock)을 얻은 단 하나의 쓰레드만 출입 가능하다.
  - 동기화가 이루어지면 쓰레드가 작업하는 동안 또 다른 쓰레드는 쓰레드가 작업하는 내용을 간섭할 수 ㅇ벗다.
      synchronized를 이용한 동기화
         1. 메서드 전체를 임계 영역으로 지정
            메서드 반환 타입 앞에 synchronized 키워드 사용
            [ public synchronized void method(){} ]
         2. 특정한 영역을 임계 영역으로 지정
            synchronized 키워드를 사용해서 블럭으로 묶는 것.
            [ synchronized(객체의 참조변수){ 임계 영역으로 지정할 문장들 } ]
      ex8 | 직접 사용해보자.

  - 동기화의 효율을 높이기 위한 Object클래스에 정의되어 있는 매서드가 있고, 동기화 블록 내에서만 사용할 수 있다.
  ( 자원을 소비하는 쓰레드 A 와 자원을 추가하는 쓰레드 B가 있다고 가정할 떄
    A쓰레드의 임계영역에 자원이 포함되어 있는 경우 만약 작업을 처리하다가 A쓰레드가 자원이 없어 작업을 처리하지 못하는 상태에서
    자원을 추가하는 B쓰레드는 A쓰레드가 걸어둔  lock 때문에 자원에 접근하지 못해 작업이 처리되지 못하고 무한정 대기상태에 빠질 수 있다.
    이 때 wait()와 notify()를 이용하여 A쓰레드는 작업이 끝나지 않아도 걸린 lock을 풀고 대기중이던 B쓰레드를 호출할 수 있다.       )
( Thread Method )
    wait() : 객체의 lock을 풀고 쓰레드를 해당 객체의 waiting pool에 넣는다.
    notify() : waiting pool에서 대기중인 쓰레드 중의 랜덤으로 하나를 깨운다.
    notifyAll() : waiting pool에서 대기중인 모든 쓰레드를 깨운다.
 ex9 | 동기화를 적용해서 직접 사용해보자.
