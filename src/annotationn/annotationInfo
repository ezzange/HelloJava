
  ## 애너테이션 ( Annotation )
 - 프로그램의 소스 코드 안에 주석과 같이 프로그램 언어에 영향을 미치지 않고 특정 프로그램을 위한 정보를 미리 약속된 형식으로 포함 시킨 것이다.
 - Annotation은 모든 애너테이션의 부모클래스이지만 상속은 불가능하다.
 - Annotation은 인터페이스이기 때문에 추상메서드를 사용할 순 있지만 구현은 불가하다.
 - 요소가 하나도 정의되지 않은 애너테이션은 Marker Annotation 이라고 한다.
 - 유효하지 않은 애너테이션은 무시된다.

  표준 애너테이션
  @Override : 오버라이딩을 올바르게 했는지 컴파일러가 체크
              (오타로 인해 올바르지 않은 오버라이딩의 경우 컴파일 에러 발생)
  @Deprecated : 앞으로 사용하지 않을 것을 권장하는 필드나 메서드에 붙여 해당 필드나 메서드를 사용할 때 알림
                (하위 호환성을 위해 삭제하지 않음)
  @FunctionalInterface : 함수형 인터페이스에 붙이면 컴파일러가 올바르게 작성했는지 체크
                         (함수형 인터페이스는 하나의 추상메서드만 가져야 함.)
  @SuppressWarnings : 컴파일러의 경고 메세지가 나타나지 않게 억제.
                      괄호 안에 억제하고자 하는 경고의 종류를 문자열로 지정할 수 있다.
 ex1 |  표준 애너테이션을 사용해보자.

  메타 애너테이션 ( 애너테이션을 만들 때 사용하는 애너테이션 )
  @Target : 애너테이션을 정의할 때, 적용 대상을 지정할 수 있음.
  @Retention : 애너테이션이 유지되는 기을 지정할 수 있고 컴파일러에 의해 사용된다.
                유지 정책
                SOURCE : 소스 파일에만 존재하고 클래스파일이 없다.
                CLASS : 클래스 파일에 존재하고 실행시에 사용 불가한 기본값.
                RUNTIME : 클래스 파일에 존재하고 실행시에도 사용 가능히다.
  @Documented : javadoc으로 작성한 문서에 포함 시킬 때 사용
  @Inherited : 부모클래스의 애너테이션을 자식 클레스에 상속 하고자 할 때 부모클래스에 사용
  @Repeatable : 반복해서 붙일 수 있는 애너테이션을 정의할 때 사용하고 해당 애너테이션이 가진 객체는 반복
                (@Repeatable 사용 시 이를 하나로 묶어 담을 컨테이너 에너테이션이 필요하다.

- 에너테이션은 직접 정의할 수 있다.
      애너테이션은 추상메서드로 선언하고 인터페이스를 선언하면 된다.. (인터페이스앞에 @를 붙인다.)
      애너테이션 적용시 애너테이션의 요소값을 지정하지 않으면. nill을 제외하고 사용될 수 있는 기본값 지정이 가능하다.
      (만약 애너테이션의 요소가 하나이고 이름이 value일 경우엔 생략 가능하다.)
      (요소의 타입이 배열일 경우, 괄호{}를 사용해야 한다. )

      - 애너테이션의 요소 타입은 기본형, String, enum, class, annotation 만 허용
      - 애너테이션이 가지고 있는 추상메서드는 매개변수를 선언할 수 없다.
      - 애너테이션은 예외를 선언할 수 없다.
      - 애너테이션은 요소를 타입 매개변수로 정의할 수 없다.
- ex2 | 애너테이션을 직접 정의해보자.